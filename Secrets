Kubernetes Secrets    > In Kubernetes, a Secret is an object that stores sensitive information such as:

Passwords
OAuth tokens
SSH keys
API keys

Unlike ConfigMaps, Secrets are specifically designed for confidential data, keeping it separate from application code and environment variables.
Secrets are base64-encoded in Kubernetes, not encrypted by default.

Secrets are stored in the Kubernetes API server.

Pods can consume secrets in two ways:
1. As environment variables
2. As mounted volumes
The kubelet fetches the secret and injects it into the pod at runtime.

Secrets are namespaced. A Secret in one namespace cannot be accessed by a pod in another namespace unless RBAC allows it.

Types of secrets

1- genric               # It used for tokcer/ssh keys/ password etc.. 
2- tls                  # It use to store SSL certificates.
3- docker-registries    # It is used for docker registry authintication in pulling images.
---------------------------------------------------------------------------------------
Viewing Secrets
kubectl get secrets                      # List all secrets
kubectl describe secret my-secret        # Describe a secret
kubectl get secret my-secret -o yaml     # Output YAML (base64 encoded)


----------------------------------------------------------------------------
Lab-1  Create mysql pod
kubectl create deploye mysql --image=mysql:5.6 --dry-run -o yaml > deploy.yaml
------------------------------------------------------------------------------------
Creating a Secret

Method 1: Using kubectl

# Create a generic secret
kubectl create secret generic my-secret \
  --from-literal=username=admin \
  --from-literal=password=MyPass123

Method 2: From a file

kubectl create secret generic my-secret \
  --from-file=ssh-privatekey=~/.ssh/id_rsa \
  --from-file=ssh-publickey=~/.ssh/id_rsa.pub

Method 3: Using YAML

apiVersion: v1
kind: Secret
metadata:
  name: my-secret
type: Opaque
data:
  username: YWRtaW4=        # base64 encoded 'admin'
  password: TXlQYXNzMTIz    # base64 encoded 'MyPass123'


Apply with:

kubectl apply -f secret.yaml
Note: Secrets require base64 encoding if using YAML.

kubectl set env deploy mysql --from=secret/dbsecret    # By command you can map secret to pod/container

In case if password change in future then you can endode password into base64 & paste directly to kubectl edit secret  & the kubectl rollout restart deploye mysql 

Lab-2  # how to store ssh keys in secret

ssh-keygen -t ed25519
kubectl create secret generic ssh-keys --from-file=.ssh/id_ed25519 --from-file=.ssh/id_ed25519.pub

now as these are files so we have to mount these to access in container  # https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/#provide-prod-test-creds

Example
  spec:
    volumes:
    - name: secret-volume
      secret:
        secretName: test-db-secret
    containers:
    - name: db-client-container
      image: myClientImage
      volumeMounts:
      - name: secret-volume
        readOnly: true
        mountPath: "/etc/secret-volume"

Now create deployment e.g kubectl create -f deploy.yml

------------------------------------------------------------------------------------------------
Lab-3

kubectl create deploy rbl --image=docker.io/zaved25/nginx   # This is a password procted image.

kubectl create secret docker-registry reg-sec \
  --docker-username=zaved25 \
  --docker-password='Religare$987' \
  --docker-server=docker.io

kubectl edit deploy rbl  # map the imagePullSecrets into deployment


Alternate method : Create a secret & map the details into default service account SA, Defaut SA is already mapped into all deployment.

-------------------------------------------------------------------

Lab-4 TLS

1) RBAC: Role based access control :
2) Use third-part crypto utils:
   1. Hashcorp-vault
   2. aws vault


kubectl create secret tls name --cert=mycerficate.crt --key=myprivate.key
kubectl get secret

kubectl edit deploy
app: nginx
name: nginx
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx
  strategy: {}
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: nginx
    spec:
      volumes:
        - name: ssh-keys
          secret:
            secretName: xyz
      containers:
        - image: nginx
          name: nginx
          volumeMounts:
            - name: ssh-keys
              readOnly: true
              mountPath: "/usr/local/ssl/certs"










